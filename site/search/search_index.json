{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#hi-im-kazi","title":"Hi, I'm Kazi!","text":"<p>Learn my ways learn how to master scripting. Be like me. I know you wish you were.</p>"},{"location":"#marvel-at-this-cat","title":"Marvel at this cat","text":"<p>He is my good friend</p>"},{"location":"Chapter%201/","title":"Chapter 1","text":""},{"location":"Chapter%201/#basics","title":"Basics","text":""},{"location":"Chapter%201/#10-basic-cs-and-programming-concepts","title":"1.0 - Basic CS and Programming Concepts","text":"<p>While you don't really need to know CS in order to code, it's very useful to understand the way your code works in the first place so you can better decide the best way to do what you want to do. Probably the most important things to have an understanding of is basic terminology and also how memory works.</p> <p>Examples for these concepts will be provided in pseudo-code (not actually real code) since this doesn't necessarily have to do with coding itself and is universal to any coding language.</p>"},{"location":"Chapter%201/#11-terminology","title":"1.1 - Terminology","text":"<ul> <li>Programming language: A language used to write programs (wow)<ul> <li>Compiled language: A programming language that is made to be directly ran by the computer itself; instructions for the computer</li> <li>Interpreted language: Also called a scripting language. A programming language that is made to be run by a separate program (the interpreter); instructions for another program</li> </ul> </li> <li>High/low level language: The further a language is away from directly interacting with the computer, the higher level it is. Scripting languages are generally high level since they interact with a program that interacts with the computer instead of just interacting with the computer</li> <li>Variable: Something that stores a value, concept from algebra</li> <li>Data types: The different types of information that can be stored in a variable. These can be simple values like numbers, letters, and words (primitive data types) or more complicated structures<ul> <li>Complex data type: A data type that holds multiple values within it</li> </ul> </li> <li>Function: Something that (generally) can take inputs (parameters), run some code, and return outputs, concept from algebra<ul> <li>Void function: A function that doesn't give an output</li> </ul> </li> <li>Bit: The smallest unit of stored information; a single binary digit (0 or 1). Most values are encoded as multiple bits, usually powers of 2.</li> </ul> <p>There is some more terminology but that will be explained within the rest of the doc sections!!</p>"},{"location":"Chapter%201/#12-memory-basics","title":"1.2 - Memory Basics","text":"<p>Memory is what a computer uses to store information. All information is stored as binary values, which basically every language will automatically do for you. Say you were to have some code like this: <pre><code>x = 10\n</code></pre> In this example, <code>x</code> is a variable set to the value <code>10</code>. Wow! When this is executed, some memory is allocated (reserved) for <code>x</code>, and is filled in with the binary value for <code>10</code>. Wherever this memory is allocated is called the memory address. Variables generally can fill their allocated memory with a new value, allowing it to change over time: <pre><code>x = 10\nx = 20\nx = 5\n</code></pre></p> <p>Generally, variables will always allocate their own memory, so if you set one variable to be equal to another variable: <pre><code>x = 10\ny = x\n</code></pre> then they will both have different memory addresses. This means that if <code>x</code> were to be changed to a different value in this example: <pre><code>x = 10\ny = x\nx = 5\n</code></pre> then <code>y</code> would still remain <code>10</code> even though it was set to <code>x</code> which is now <code>5</code>; instead of copying <code>x</code> itself it copies whatever <code>x</code> is currently equal to. There are, however, reference variables which do refer to the exact memory address of another variable, effectively making it so it changes with it: <pre><code>x = 10\ny references x\nx = 5\n</code></pre> in this example, <code>y</code>, like <code>x</code>, will start out as <code>10</code> and be changed to <code>5</code>. Most higher-level languages will not use references unless it is for more complicated data types than just numbers.</p> <p>Memory is physically stored, so there is a limit to how much can be stored. You will generally never hit this limit on a modern computer unless you REALLY fuck up, but generally the less you have available the slower everything is, so you want to avoid keeping useless memory allocated. When useless memory is kept allocated, it is called a memory leak. Scripting languages typically have garbage collectors that detect when memory is 100% not used and won't be used and automatically deallocates it, doing most of the job for you.</p>"},{"location":"Chapter%201/#13-data-types","title":"1.3 - Data Types","text":"<p>Data is always stored in the same binary format, so the computer uses its data type to know how to understand it. Different data types will require more or less memory to store information. The most common data types are:</p> <ul> <li>Int(integer): A positive or negative whole number</li> <li>Float(ing point): A number that can have a decimal<ul> <li>Double: A float that uses twice the information, so it can store bigger numbers</li> </ul> </li> <li>Bool(ean): A binary value, usually represented as being either <code>true</code> or <code>false</code></li> <li>Str(ing): Any text/characters. Typically represented by wrapping it between <code>\"\"</code> or <code>''</code>. Strings might sometimes look like other value types (e.g. <code>\"true\"</code> or <code>\"5\"</code>) but they are treated just as any other string</li> <li>Null: Called <code>nil</code> in lua, just represents there being no value at all</li> </ul> <p>A language that is strongly typed will require you to manually define the type of a variable. Many scripting languages aren't, and instead automatically assume it based on the value.</p> <p>There are more complex data types, but these generally depend on the language itself. The most common one that is practically universal between languages is the array. An array is essentially an ordered list of multiple values. Most languages are 0-index, meaning that the first value stored in an array is treated like the 0th value, but Lua (what Roblox uses) is 1-index, meaning that the first value is treated as the 1st. Here is an example of the way an array works in a 1-index language: <pre><code>a = [5, \"something\", false]\n\nx = a[1]\ny = a[2]\nz = a[3]\n</code></pre> In this example, <code>a</code> is set to an array containing the values <code>5</code> (an int), <code>\"something\"</code> (a string), and <code>false</code> (a bool). <code>x</code> is then set to the <code>1</code>st element of the array (<code>5</code>), <code>y</code> to the <code>2</code>nd (<code>\"something\"</code>), <code>z</code> to the <code>3</code>rd (<code>false</code>). This process of referring to a specific value within a complex data structure is called indexing.</p>"},{"location":"Chapter%201/#14-functions","title":"1.4 - Functions","text":"<p>A function can generally take in any number of inputs (parameters) and return any number of outputs. Functions can also store code within them that runs whenver the function is called (used). Whatever values are passed into the function (arguments) will fill in the values of the parameters. Might not have been the simplest way to explain it but an example should clear stuff up (using Lua for the example this time): <pre><code>-- In lua, doing -- makes the rest of the line a comment. You can write anything in a comment and it won't run\nfunction add(number1, number2) -- All the code between here and 'end' will run when the funciton is called\n    -- The parameters are 'number1' and 'number2'\n\n    local sum = number1 + number2 -- 'local' basically means in Lua that this is a new variable and not just changing the value of one that already exists\n    return sum -- Returning values ends the function immedeately and gives it a value\n\nend\n\nlocal x = add(5, 7) -- The arguments here are 5 and 7. This means that when 'add' is called this time, the parameter number1 will be 5 and the parameter number2 will be 7. This will make the sum variable 5+7 and thus 12 will be returned. x is set to the return value, so x is now 12\n\nlocal y = add(8, 9) - 1 -- Figure out what the arguments are, what 'sum' will be equal to in this case, what gets returned, and what y is equal to`\n</code></pre></p> The arguments are: 8 and 9, meaning that when add is called in the highlighted line, number1 will equal 8 and number2 will equal 9   The value returned is: 17. sum is set to equal number1 (8) + number2 (9) which is 17. sum is then returned  y will be equal to: 16. y is set to equal the return value of add(8, 9) - 1. The return value is 17, and 17 - 1 is 16.  <p>Most programming languages come with many built-in functions. The <code>print</code> function will log any arguments into the program's output. <pre><code>print(\"something\", 5-9, false)\n</code></pre> Output:</p> <p>\"something\"  -14  false</p>"},{"location":"Chapter%201/#15-operations","title":"1.5 - Operations","text":"<p>Operations are pretty simple. The symbols for operations are almost entirely the same between languages, but there are some differences and I will be using the way they are done in lua. In lua, the value types number (int, float, and double are all treated as one type in lua), string, and boolean all have unique operations, and there are some operations that are universal to all data types. They are all generally straightforwards, although boolean operations are somewhat difficult.</p> <p>Universal operations:</p> <ul> <li>Equality: <code>a == b</code> outputs <code>true</code> if the values are equivilent and <code>false</code> otherwise<ul> <li><code>5 == 3</code> outputs <code>false</code></li> </ul> </li> <li>Unequality: <code>a ~= b</code> outputs <code>true</code> if the values are not the same and <code>false</code> otherwise<ul> <li><code>5 ~= 3</code> outputs <code>true</code></li> </ul> </li> <li>If these are used with complex data types, it will compare their memory addresses instead of the values themselves</li> </ul> <p>Numerical operations (arithmetic):</p> <ul> <li>Addition: <code>a + b</code> outputs the sum of the two numbers<ul> <li><code>5 + 3</code> outputs <code>8</code></li> </ul> </li> <li>Subtraction: <code>a - b</code> outputs the difference of the two numbers<ul> <li><code>5 - 3</code> outputs <code>2</code></li> </ul> </li> <li>Multiplication: <code>a * b</code> outputs the product of the two numbers<ul> <li><code>5 * 3</code> outputs <code>15</code></li> </ul> </li> <li>Division: <code>a / b</code> outputs the quotient of the two numbers<ul> <li><code>5 / 3</code> outputs <code>1.66666666666...</code></li> </ul> </li> <li>Exponentiation: <code>a ^ b</code> outputs <code>a</code> to the power of <code>b</code><ul> <li><code>5 ^ 3</code> outputs <code>125</code></li> </ul> </li> </ul> <p>These all follow the standard order of operations. Parentheses can be used.</p> <p>Numerical operations (Inequalities):</p> <ul> <li>Greater than or equal to: <code>a &gt;= b</code> outputs <code>true</code> if <code>a</code> is greater than or equal to <code>b</code> and <code>false</code> otherwise<ul> <li><code>5 &gt;= 3</code> outputs <code>true</code></li> </ul> </li> <li>Less than or equal to: <code>a &lt;= b</code> outputs <code>true</code> if <code>a</code> is less than or equal to <code>b</code> and <code>false</code> otherwise<ul> <li><code>5 &lt;= 3</code> outputs <code>false</code></li> </ul> </li> </ul> <p>String operations (there's really only one):</p> <ul> <li>Concatination: <code>a .. b</code> combines the two strings into one<ul> <li><code>\"combined \"..\"words\"</code> outputs <code>\"combined words\"</code></li> </ul> </li> </ul>"},{"location":"Chapter%201/#151-boolean-operations","title":"1.5.1 - Boolean Operations","text":"<p>These get their own sections because they're kind of complicated. Boolean operations can actually be used on any data type, not just booleans. However, they are based on boolean math and treat data types as if they were either <code>true</code> or <code>false</code> even if they are not booleans. If a data type is treated as being <code>true</code> it is truthy and if it is treated as being false it is falsey. In lua, all data types are truthy except <code>false</code> and <code>nil</code>.</p> <ul> <li><code>a and b</code> outputs <code>b</code> if <code>a</code> is truthy, otherwise outputs <code>a</code><ul> <li><code>true and 5</code> outputs <code>5</code></li> <li><code>false and 3</code> outputs <code>false</code></li> <li><code>nil and false</code> outputs <code>nil</code></li> </ul> </li> <li><code>a or b</code> outputs <code>a</code> if <code>a</code> is truthy, otherwise outputs <code>b</code><ul> <li><code>true or 5</code> outputs <code>true</code></li> <li><code>false or 3</code> outputs <code>3</code></li> <li><code>nil or false</code> outputs <code>false</code></li> </ul> </li> <li><code>not a</code> outputs <code>false</code> if <code>a</code> is truthy, otherwise outputs <code>true</code><ul> <li><code>not true</code> output <code>false</code></li> <li><code>not 5</code> outputs <code>false</code></li> <li><code>not nil</code> outputs <code>true</code></li> <li><code>not false</code> outputs <code>true</code></li> <li><code>not not 2</code> outputs <code>true</code></li> </ul> </li> </ul> <p>Now try to see if you can figure out these values!</p> 5 and 3 3  2 or 3 2  5*5 or 1 25  nil and 2*2 nil  true and \"wow\" or \"woah\" \"wow\"  (not true) and \"wow\" or (not not \"woah\") true  5 == 3 and \"calla likes girls\" or 3 == 2 and \"what\" or 2*2 == 2^2 and \"kazi is so pretty\" \"kazi is so pretty\"  <p>That's it for all the computer science/math based stuff! Wow! You did it! Yay! More coming soon!</p>"},{"location":"Chapter%201b/","title":"Chapter 1b","text":""},{"location":"Chapter%201b/#basics-in-lua","title":"Basics in Lua","text":""},{"location":"Chapter%201b/#1b0-basic-programming-concepts-in-lua","title":"1b.0 - Basic Programming Concepts in Lua","text":"<p>The previous chapter was more general to all programming languages. Since the rest of this doc will be on lua specifically, I'll show how everything in the previous chapter works in lua. Well that's kind of a lie, it'll actually be Luau, Roblox's derivitive of lua. Luau has all the features of lua with some extra stuff on top of it.</p>"},{"location":"Chapter%201b/#1b1-complex-data-types","title":"1b.1 Complex Data Types","text":"<p>A lot of programming languages have the complex data types hashmap/dictionary / and array*. An array, as explained before, just contains multiple values in an ordered list. A hashmap maps \"keys\" to \"values\". For example, in javascript <pre><code>let Player = {\n    \"health\": 100, // Key is \"health\", value is 100\n    \"name\": \"Kazi\", // Key is \"name\", value is \"Kazi\"\n    \"age\": 18, //Key is \"age\", value is 18\n\n}\n</code></pre> You can then index it to get values (e.g. <code>Player[\"health\"]</code> will be <code>100</code>)</p> <p>Instead of having structs and arrays, lua has tables which can represent both: <pre><code>local arrayTable = {5, \"something\", false}\nlocal playerTable = {\n    [\"health\"] = 100,\n    [\"name\"] = \"Kazi\",\n    [\"age\"] = 18,\n\n}\n</code></pre> An array table is just an automated way to do the following: <pre><code>{\n    [1] = ...,\n    [2] = ...,\n    [3] = ...,\n    ...\n}\n</code></pre> You can modify the values inside of a table, or even add new ones: <pre><code>arrayTable[3] = true -- arrayTable is now {5, \"something\", true}\nplayerTable[\"cute\"] = true -- playerTable is now { [\"health\"] = 100, [\"name\"] = \"Kazi\", [\"age\"] = 18, [\"cute\"] = true, }\n</code></pre></p>"},{"location":"Chapter%201b/#1b2-references","title":"1b.2 References","text":"<p>Lua doesn't have references for the most part. However, variables set to tables will always act as references: <pre><code>local playerTable = {\n    [\"health\"] = 100,\n    [\"name\"] = \"Kazi\",\n    [\"age\"] = 18,\n    [\"cute\"] = true,\n\n}\n\nlocal playerNamedKazi = playerTable\nplayerNamedKazi[\"health\"] = 80 -- This affects playerTable!! Now they will both be { [\"health\"] = 80, [\"name\"] = \"Kazi\", [\"age\"] = 18, [\"cute\"] = true, }\n</code></pre></p> <p>Wow! We good for progressing now!</p>"}]}