{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#hi-im-kazi","title":"Hi, I'm Kazi!","text":"<p>Learn my ways learn how to master scripting. Be like me. I know you wish you were.</p>"},{"location":"#marvel-at-this-cat","title":"Marvel at this cat","text":"<p>He is my good friend</p>"},{"location":"Chapter%201/","title":"Chapter 1","text":""},{"location":"Chapter%201/#basics","title":"Basics","text":""},{"location":"Chapter%201/#10-basic-cs-and-programming-concepts","title":"1.0 - Basic CS and Programming Concepts","text":"<p>While you don't really need to know CS in order to code, it's very useful to understand the way your code works in the first place so you can better decide the best way to do what you want to do. Probably the most important things to have an understanding of is basic terminology and also how memory works.</p> <p>Examples for these concepts will be provided in pseudo-code (not actually real code) since this doesn't necessarily have to do with coding itself and is universal to any coding language.</p>"},{"location":"Chapter%201/#11-terminology","title":"1.1 - Terminology","text":"<ul> <li>Programming language: A language used to write programs (wow)<ul> <li>Compiled language: A programming language that is made to be directly ran by the computer itself; instructions for the computer</li> <li>Interpreted language: Also called a scripting language. A programming language that is made to be run by a separate program (the interpreter); instructions for another program</li> </ul> </li> <li>High/low level language: The further a language is away from directly interacting with the computer, the higher level it is. Scripting languages are generally high level since they interact with a program that interacts with the computer instead of just interacting with the computer</li> <li>Variable: Something that stores a value, concept from algebra</li> <li>Data types: The different types of information that can be stored in a variable. These can be simple values like numbers, letters, and words (primitive data types) or more complicated structures<ul> <li>Complex data type: A data type that holds multiple values within it</li> </ul> </li> <li>Function: Something that (generally) can take inputs (parameters), run some code, and return outputs, concept from algebra<ul> <li>Void function: A function that doesn't give an output</li> </ul> </li> <li>Bit: The smallest unit of stored information; a single binary digit (0 or 1). Most values are encoded as multiple bits, usually powers of 2.</li> </ul> <p>There is some more terminology but that will be explained within the rest of the doc sections!!</p>"},{"location":"Chapter%201/#12-memory-basics","title":"1.2 - Memory Basics","text":"<p>Memory is what a computer uses to store information. All information is stored as binary values, which basically every language will automatically do for you. Say you were to have some code like this: <pre><code>x = 10\n</code></pre> In this example, <code>x</code> is a variable set to the value <code>10</code>. Wow! When this is executed, some memory is allocated (reserved) for <code>x</code>, and is filled in with the binary value for <code>10</code>. Wherever this memory is allocated is called the memory address. Variables generally can fill their allocated memory with a new value, allowing it to change over time: <pre><code>x = 10\nx = 20\nx = 5\n</code></pre></p> <p>Generally, variables will always allocate their own memory, so if you set one variable to be equal to another variable: <pre><code>x = 10\ny = x\n</code></pre> then they will both have different memory addresses. This means that if <code>x</code> were to be changed to a different value in this example: <pre><code>x = 10\ny = x\nx = 5\n</code></pre> then <code>y</code> would still remain <code>10</code> even though it was set to <code>x</code> which is now <code>5</code>; instead of copying <code>x</code> itself it copies whatever <code>x</code> is currently equal to. There are, however, reference variables which do refer to the exact memory address of another variable, effectively making it so it changes with it: <pre><code>x = 10\ny references x\nx = 5\n</code></pre> in this example, <code>y</code>, like <code>x</code>, will start out as <code>10</code> and be changed to <code>5</code>. Most higher-level languages will not use references unless it is for more complicated data types than just numbers.</p> <p>Memory is physically stored, so there is a limit to how much can be stored. You will generally never hit this limit on a modern computer unless you REALLY fuck up, but generally the less you have available the slower everything is, so you want to avoid keeping useless memory allocated. When useless memory is kept allocated, it is called a memory leak. Scripting languages typically have garbage collectors that detect when memory is 100% not used and won't be used and automatically deallocates it, doing most of the job for you.</p>"},{"location":"Chapter%201/#13-data-types","title":"1.3 - Data Types","text":"<p>Data is always stored in the same binary format, so the computer uses its data type to know how to understand it. Different data types will require more or less memory to store information. The most common data types are:</p> <ul> <li>Int(integer): A positive or negative whole number</li> <li>Float(ing point): A number that can have a decimal<ul> <li>Double: A float that uses twice the information, so it can store bigger numbers</li> </ul> </li> <li>Bool(ean): A binary value, usually represented as being either <code>true</code> or <code>false</code></li> <li>Str(ing): Any text/characters. Typically represented by wrapping it between <code>\"\"</code> or <code>''</code>. Strings might sometimes look like other value types (e.g. <code>\"true\"</code> or <code>\"5\"</code>) but they are treated just as any other string</li> <li>Null: Called <code>nil</code> in lua, just represents there being no value at all</li> </ul> <p>A language that is strongly typed will require you to manually define the type of a variable. Many scripting languages aren't, and instead automatically assume it based on the value.</p> <p>There are more complex data types, but these generally depend on the language itself. The most common one that is practically universal between languages is the array. An array is essentially an ordered list of multiple values. Most languages are 0-index, meaning that the first value stored in an array is treated like the 0th value, but Lua (what Roblox uses) is 1-index, meaning that the first value is treated as the 1st. Here is an example of the way an array works in a 1-index language: <pre><code>a = [5, \"something\", false]\n\nx = a[1]\ny = a[2]\nz = a[3]\n</code></pre> In this example, <code>a</code> is set to an array containing the values <code>5</code> (an int), <code>\"something\"</code> (a string), and <code>false</code> (a bool). <code>x</code> is then set to the <code>1</code>st element of the array (<code>5</code>), <code>y</code> to the <code>2</code>nd (<code>\"something\"</code>), <code>z</code> to the <code>3</code>rd (<code>false</code>). This process of referring to a specific value within a complex data structure is called indexing.</p>"},{"location":"Chapter%201/#14-functions","title":"1.4 - Functions","text":"<p>A function can generally take in any number of inputs (parameters) and return any number of outputs. Functions can also store code within them that runs whenver the function is called (used). Whatever values are passed into the function (arguments) will fill in the values of the parameters. Might not have been the simplest way to explain it but an example should clear stuff up (using Lua for the example this time): <pre><code>-- In lua, doing -- makes the rest of the line a comment. You can write anything in a comment and it won't run\nfunction add(number1, number2) -- All the code between here and 'end' will run when the funciton is called\n    -- The parameters are 'number1' and 'number2'\n\n    local sum = number1 + number2 -- 'local' basically means in Lua that this is a new variable and not just changing the value of one that already exists\n    return sum -- Returning values ends the function immedeately and gives it a value\n\nend\n\nlocal x = add(5, 7) -- The arguments here are 5 and 7. This means that when 'add' is called this time, the parameter number1 will be 5 and the parameter number2 will be 7. This will make the sum variable 5+7 and thus 12 will be returned. x is set to the return value, so x is now 12\n\nlocal y = add(8, 9) - 1 -- Figure out what the arguments are, what 'sum' will be equal to in this case, what gets returned, and what y is equal to`\n</code></pre></p> The arguments are: 8 and 9, meaning that when add is called in the highlighted line, number1 will equal 8 and number2 will equal 9   The value returned is: 17. sum is set to equal number1 (8) + number2 (9) which is 17. sum is then returned  y will be equal to: 16. y is set to equal the return value of add(8, 9) - 1. The return value is 17, and 17 - 1 is 16.  <p>Most programming languages come with many built-in functions. The <code>print</code> function will log any arguments into the program's output. <pre><code>print(\"something\", 5-9, false)\n</code></pre> Output:</p> <p>\"something\"  -14  false</p>"},{"location":"Chapter%201/#15-operations","title":"1.5 - Operations","text":"<p>Operations are pretty simple. The symbols for operations are almost entirely the same between languages, but there are some differences and I will be using the way they are done in lua. In lua, the value types number (int, float, and double are all treated as one type in lua), string, and boolean all have unique operations, and there are some operations that are universal to all data types. They are all generally straightforwards, although boolean operations are somewhat difficult.</p> <p>Universal operations:</p> <ul> <li>Equality: <code>a == b</code> outputs <code>true</code> if the values are equivilent and <code>false</code> otherwise<ul> <li><code>5 == 3</code> outputs <code>false</code></li> </ul> </li> <li>Unequality: <code>a ~= b</code> outputs <code>true</code> if the values are not the same and <code>false</code> otherwise<ul> <li><code>5 ~= 3</code> outputs <code>true</code></li> </ul> </li> <li>If these are used with complex data types, it will compare their memory addresses instead of the values themselves</li> </ul> <p>Numerical operations (arithmetic):</p> <ul> <li>Addition: <code>a + b</code> outputs the sum of the two numbers<ul> <li><code>5 + 3</code> outputs <code>8</code></li> </ul> </li> <li>Subtraction: <code>a - b</code> outputs the difference of the two numbers<ul> <li><code>5 - 3</code> outputs <code>2</code></li> </ul> </li> <li>Multiplication: <code>a * b</code> outputs the product of the two numbers<ul> <li><code>5 * 3</code> outputs <code>15</code></li> </ul> </li> <li>Division: <code>a / b</code> outputs the quotient of the two numbers<ul> <li><code>5 / 3</code> outputs <code>1.66666666666...</code></li> </ul> </li> <li>Exponentiation: <code>a ^ b</code> outputs <code>a</code> to the power of <code>b</code><ul> <li><code>5 ^ 3</code> outputs <code>125</code></li> </ul> </li> </ul> <p>These all follow the standard order of operations. Parentheses can be used.</p> <p>Numerical operations (Inequalities):</p> <ul> <li>Greater than or equal to: <code>a &gt;= b</code> outputs <code>true</code> if <code>a</code> is greater than or equal to <code>b</code> and <code>false</code> otherwise<ul> <li><code>5 &gt;= 3</code> outputs <code>true</code></li> </ul> </li> <li>Less than or equal to: <code>a &lt;= b</code> outputs <code>true</code> if <code>a</code> is less than or equal to <code>b</code> and <code>false</code> otherwise<ul> <li><code>5 &lt;= 3</code> outputs <code>false</code></li> </ul> </li> </ul> <p>String operations (there's really only one):</p> <ul> <li>Concatination: <code>a .. b</code> combines the two strings into one<ul> <li><code>\"combined \"..\"words\"</code> outputs <code>\"combined words\"</code></li> </ul> </li> </ul>"},{"location":"Chapter%201/#151-boolean-operations","title":"1.5.1 - Boolean Operations","text":"<p>These get their own sections because they're kind of complicated. Boolean operations can actually be used on any data type, not just booleans. However, they are based on boolean math and treat data types as if they were either <code>true</code> or <code>false</code> even if they are not booleans. If a data type is treated as being <code>true</code> it is truthy and if it is treated as being false it is falsey. In lua, all data types are truthy except <code>false</code> and <code>nil</code>.</p> <ul> <li><code>a and b</code> outputs <code>b</code> if <code>a</code> is truthy, otherwise outputs <code>a</code><ul> <li><code>true and 5</code> outputs <code>5</code></li> <li><code>false and 3</code> outputs <code>false</code></li> <li><code>nil and false</code> outputs <code>nil</code></li> </ul> </li> <li><code>a or b</code> outputs <code>a</code> if <code>a</code> is truthy, otherwise outputs <code>b</code><ul> <li><code>true or 5</code> outputs <code>true</code></li> <li><code>false or 3</code> outputs <code>3</code></li> <li><code>nil or false</code> outputs <code>false</code></li> </ul> </li> <li><code>not a</code> outputs <code>false</code> if <code>a</code> is truthy, otherwise outputs <code>true</code><ul> <li><code>not true</code> output <code>false</code></li> <li><code>not 5</code> outputs <code>false</code></li> <li><code>not nil</code> outputs <code>true</code></li> <li><code>not false</code> outputs <code>true</code></li> <li><code>not not 2</code> outputs <code>true</code></li> </ul> </li> </ul> <p>Now try to see if you can figure out these values!</p> 5 and 3 3  2 or 3 2  5*5 or 1 25  nil and 2*2 nil  true and \"wow\" or \"woah\" \"wow\"  (not true) and \"wow\" or (not not \"woah\") true  5 == 3 and \"calla likes girls\" or 3 == 2 and \"what\" or 2*2 == 2^2 and \"kazi is so pretty\" \"kazi is so pretty\"  <p>That's it for all the computer science/math based stuff! Wow! You did it! Yay! More coming soon!</p>"},{"location":"Chapter%201b/","title":"Chapter 1b","text":""},{"location":"Chapter%201b/#basics-in-lua","title":"Basics in Lua","text":""},{"location":"Chapter%201b/#1b0-basic-programming-concepts-in-lua","title":"1b.0 - Basic Programming Concepts in Lua","text":"<p>The previous chapter was more general to all programming languages. Since the rest of this doc will be on lua specifically, I'll show how everything in the previous chapter works in lua. Well that's kind of a lie, it'll actually be Luau, Roblox's derivitive of lua. Luau has all the features of lua with some extra stuff on top of it.</p>"},{"location":"Chapter%201b/#1b1-complex-data-types","title":"1b.1 - Complex Data Types","text":"<p>A lot of programming languages have the complex data types hashmap/dictionary and array. An array, as explained before, just contains multiple values in an ordered list. A hashmap maps \"keys\" to \"values\". For example, in javascript <pre><code>let Player = {\n    \"health\": 100, // Key is \"health\", value is 100\n    \"name\": \"Kazi\", // Key is \"name\", value is \"Kazi\"\n    \"age\": 18, // Key is \"age\", value is 18\n\n}\n</code></pre> You can then index it to get values (e.g. <code>Player[\"health\"]</code> will be <code>100</code>)</p> <p>Instead of having dictionaries and arrays, lua has tables which can represent both: <pre><code>local arrayTable = {5, \"something\", false}\nlocal playerTable = {\n    [\"health\"] = 100,\n    [\"name\"] = \"Kazi\",\n    [\"age\"] = 18,\n\n}\n</code></pre> An array table is just an automated way to do the following: <pre><code>{\n    [1] = ...,\n    [2] = ...,\n    [3] = ...,\n    ...\n}\n</code></pre> You can modify the values inside of a table, or even add new ones: <pre><code>arrayTable[3] = true -- arrayTable is now {5, \"something\", true}\nplayerTable[\"cute\"] = true -- playerTable is now { [\"health\"] = 100, [\"name\"] = \"Kazi\", [\"age\"] = 18, [\"cute\"] = true, }\n</code></pre></p>"},{"location":"Chapter%201b/#1b2-references","title":"1b.2 - References","text":"<p>Lua doesn't have references for the most part. However, variables set to tables will always act as references: <pre><code>local playerTable = {\n    [\"health\"] = 100,\n    [\"name\"] = \"Kazi\",\n    [\"age\"] = 18,\n    [\"cute\"] = true,\n\n}\n\nlocal playerNamedKazi = playerTable\nplayerNamedKazi[\"health\"] = 80 -- This affects playerTable!! Now they will both be { [\"health\"] = 80, [\"name\"] = \"Kazi\", [\"age\"] = 18, [\"cute\"] = true, }\n</code></pre></p> <p>Wow! We good for progressing now!</p>"},{"location":"Chapter%202/","title":"Chapter 2","text":""},{"location":"Chapter%202/#conditionals-and-iterations","title":"Conditionals and Iterations","text":""},{"location":"Chapter%202/#20-conditionals-and-iterations-in-lua","title":"2.0 - Conditionals and Iterations in Lua","text":"<p>Conditionals are fundamental for programming. They allow your code to do different things depending on the situation. Iteration is fundamental for automating things and making code less repetitive. Wow!</p>"},{"location":"Chapter%202/#21-conditionals","title":"2.1 - Conditionals","text":"<p>A conditional is something that runs code only if a certain condition is met. The most basic conditional is the <code>if</code> statement: <pre><code>if (condition) then\n    -- run something\nend\n</code></pre> The <code>if</code> statement evaluates a single condition. If whatever is put into it is truthy, then the code inside of it (between <code>then</code> and <code>end</code>) will run. Otherwise, it skips over to <code>end</code>. For example: <pre><code>local age = 16\n\nif age &lt; 18 then\n    print(\"Roblox devs want you\")\nend\n</code></pre> Here, <code>age &lt; 18</code> gives the value <code>true</code>. Since <code>true</code> is truthy, the code inside of it runs. There are two extra conditionals that function within an <code>if</code> statement: <code>elseif</code> and <code>else</code>: <pre><code>if (condition1) then\n    print(\"condition1 is truthy, only this will run\")\nelseif (condition2) then\n    print(\"condition1 is falsey but condition2 is truthy! Only this will run\")\nelseif (condition3) then\n    print(\"condition1 and condition2 are falsey but condition3 is truthy! Only this will run\")\nelse\n    print(\"Every above condition was falsey, so only this will run\")\nend\n</code></pre></p>"},{"location":"Chapter%202/#22-iteration","title":"2.2 - Iteration","text":"<p>There are many ways to iterate in lua. Iteration is the process of repeating an instruction multiple times, a single repetition being called an iteration. It can be achieved with loops and recursive functions. Both are fundamentally based on conditionals. When iterating, it is important to make sure that the iteration eventually ends or pauses, otherwise it will cause a stack overflow error where it essentially tries and fails to do an infinite amount of tasks at once. For most of the following examples, the methods for iteration will count upwards from <code>1</code> and stop when it reaches <code>10</code>.</p>"},{"location":"Chapter%202/#23-recursive-functions","title":"2.3 - Recursive Functions","text":"<p>A recursive function is a function that calls itself within its own execution: <pre><code>local function countToTen(currentNumber)\n    print(\"Counted\", currentNumber)\n\n    if currentNumber &lt; 10 then\n        countToTen(currentNumber + 1)\n    end\n\nend\n\ncountToTen(1)\n</code></pre> The function will first on the last line run with the argument <code>1</code>, meaning that <code>currentNumber</code> will equal <code>1</code>. It will then print <code>\"Counted\" 1</code> and check if <code>currentNumber &lt; 10</code>. As <code>1 &lt; 10</code>, this will result in <code>true</code>, and thus the code inside of the <code>if</code> statement runs. It calls itself again with the argument <code>currentNumber + 1</code>, which would be <code>1 + 1</code>, meaning this time <code>currentNumber</code> will be <code>2</code>. It will keep doing this over and over again until the condition checked by the <code>if</code> statement is false, which is when the argument is <code>10</code>. This will result in the following output:</p> <p>\"Counted\" 1 \"Counted\" 2 \"Counted\" 3 \"Counted\" 4 \"Counted\" 5 \"Counted\" 6 \"Counted\" 7 \"Counted\" 8 \"Counted\" 9 \"Counted\" 10</p>"},{"location":"Chapter%202/#24-while-loop","title":"2.4 - While Loop","text":"<p>Generally, for something as simple as this, a loop is prefered. The <code>while</code> loop repeatedly evaluates a condition and runs code until thaat condition is falsey: <pre><code>local currentNumber = 1\nwhile currentNumber &lt;= 10 do\n    print(\"Counted\", currentNumber)\n\n    currentNumber = currentNumber + 1\n\nend\n</code></pre> The way this code works is that it first evaluates <code>currentNumber &lt;= 10</code>. Since that is <code>true</code> and thus truthy, the code inside the <code>while</code> loop runs. By the end of this, <code>currentNumber</code> becomes <code>2</code>. As <code>2</code> is still less than or equal to <code>10</code>, the code inside the <code>while</code> loop will run again. It will keep doing this until <code>currentNumber</code> becomes <code>11</code>, and as <code>11 &lt; 10</code> would give false, the code inside the while loop would stop running. It is important to note that this uses <code>&lt;= 10</code> whereas the recursive function uses <code>&lt; 10</code> as <code>currentNumber</code> is increased before it checks its value <code>while</code> loop while it's effectively increased after it checks its value.</p> <p>Loops can prematurely be ended (similar to <code>return</code> in a function) using <code>break</code>: <pre><code>local currentNumber = 1\nwhile true do -- This condition will always be truthy, so the while loop will theoretically run infinitely. However, we eventually break out of it, so it does not cause a stack overflow\n    print(\"Counted\", currentNumber)\n\n    if currentNumber &gt;= 10 then\n        break\n    end\n\n    currentNumber = currentNumber + 1\n\nend\n</code></pre> The way the loop works this time is that it will firstly always run, as the condition we gave it is forever just <code>true</code>. It will then evaluate <code>currentNumber &gt;= 10</code> within the loop. As <code>1 &gt;= 10</code> is <code>false</code> which is falsey, what's inside of the <code>if</code> statement won't run and it will not break. <code>currentNumber</code> then is increased and the loop runs again. It will keep doing this until <code>currentNumber &gt;= 10</code> is <code>true</code>, where it will then finally break, ending before <code>currentNumber</code> can be set to 11.</p>"},{"location":"Chapter%202/#25-for-loop","title":"2.5 - For Loop","text":"<p>There are two types of <code>for</code> loops in Lua, one that simply counts a variable upwards until it reaches a certain value (exactly what we want for this) called the numeric for, and one that uses an iterator function (this one's more complicated) called the generic for. The first type works like this: <pre><code>for currentNumber = 1, 10, 1 do --1, 10, 1 means start at 1, stop at 10, increase by 1 every iteration. If a third number is not provided, it will automatically assume it is 1\n    print(\"Counted\", currentNumber)\nend\n</code></pre> This code will create a <code>currentNumber</code> variable that only exists within the <code>for</code> loop and then sets it to <code>1</code>. It will then run the code within it, and increase it by <code>1</code>. It will keep doing this until it reaches <code>10</code>, where it will then iterate one final time. Like <code>while</code> loops, <code>for</code> loops can be prematurely ended with <code>break</code>.</p>"},{"location":"Chapter%202/#251-generic-for-loop","title":"2.5.1 - Generic For Loop","text":"<p>The second type of <code>for</code> loop is definitely the most complicated method of iterating. The easiest way to do it is by analyzing an example: <pre><code>local function iterator(limit, currentValue)\n    currentValue = currentValue and currentValue + 1 or 1\n\n    if currentValue &gt; limit then\n        return nil\n    end\n\n    return currentValue\n\nend\n\nfor currentNumber in iterator, 10 do\n    print(\"Counted\", currentNumber)\nend\n</code></pre> Now we gotta break down how this all works. So, firstly, we can tell that this is a generic <code>for</code> as it uses <code>in</code> and an iterator function. The iteration function will then be called, and the arguments passed will be whatever is to the right of the indicator (<code>10</code>) and whatever is returned by the previous iteration (since there is no previous iteration, it will just be <code>nil</code>). This means in the first iteration, it calls <code>iterator(10, nil)</code>. The first line of the iterator function changes <code>currentValue</code> to be <code>currentValue and currentValue + 1 or 1</code>. Substituting in its value for this iteration gives us <code>nil and nil + 1 or 1</code> (which can be read as <code>(nil and nil + 1) or 1</code>). This simplifies to <code>nil or 1</code> which gives <code>1</code>. It then checks <code>currentValue &gt; limit</code>, which would be <code>1 &gt; 10</code>, which is false, meaning the <code>if</code> won't run. Finally, it returns <code>currentValue</code> which is again, now <code>1</code>. This return value gets put into <code>currentNumber</code>, and then the contents of the for loop run, printing out <code>\"Counted\" 1</code>. The for loop then iterates again, using the previous iteration's output (<code>1</code>) as an additional argument for <code>iterator</code>, meaning that this time it now calls <code>iterator(10, 1)</code>. This means that this time <code>limit</code> is still <code>10</code> and <code>currentValue</code> is now 1, resulting in <code>currentValue and currentValue + 1 or 1</code> giving <code>1 and 1 + 1 or 1</code>, or <code>1 and 2 or 1</code>, finally giving 2. The condition for the <code>if</code> statement still is not met, meaning that it returns <code>currentValue</code>, which is now <code>2</code>. This gets fed into <code>currentNumber</code>, it runs the code inside the <code>for</code> loop again, and this keeps repeating until <code>iterator</code> eventually returns nil.</p> <p>That was a lot of information wow. Good job princesses!</p>"},{"location":"Chapter%203/","title":"Chapter 3","text":""},{"location":"Chapter%203/#state-and-behavior-object-oriented-programming","title":"State and Behavior, Object Oriented Programming","text":""},{"location":"Chapter%203/#30-state-and-behavior-in-lua-via-oop","title":"3.0 - State and Behavior in Lua via OOP","text":"<p>State and behavior describe the two main aspects of what code does. State describes the properties of something and behavior describes how it acts based on the state. In object oriented programming (OOP), which is one of the most common and widely-used programming paradigms (styles), state and behavior are grouped together in \"objects\", which can be represented as tables in lua. Objects typically follow a blueprint (the class), which can inherit from base classes (essentially copy a base class and add extra stuff to it). Properties are values stored within the object that describe its state, and methods are functions that are referenced within the object that act based on its state. Lua tables are specially set up to allow for OOP to look more elagant, which will be covered as we go over how OOP is implemented in lua. In this chapter, we will create a <code>Player</code> class as an example.</p>"},{"location":"Chapter%203/#31-objects-as-tables","title":"3.1 - Objects as Tables","text":"<p>In lua, properties are fundamentally represented as hashmaps with string keys. As a refresher, hashmaps map \"keys\" to \"values\": <pre><code>local hashmap = {\n    [\"key\"] = \"value\", -- String key \"key\" mapped to string value \"value\"\n    [2] = true, -- Number key 2 mapped to boolean value true\n\n}\n\nlocal x = hashmap[\"key\"] -- x = \"value\"\nlocal y = hashmap[2] -- y = true\n</code></pre> Because of how common string keys are, lua has a more simplified format for them: <pre><code>local hashmap = {\n    key1 = \"value1\", -- Simplified\n    [\"key2\"] = \"value2\",\n}\nlocal w = hashmap.key1 -- \"value1\"\nlocal x = hashmap[\"key1\"] -- Still \"value1\"\nlocal y = hashmap.key2 -- \"value2\"\nlocal z = hashmap[\"key2\"] -- Still \"value2\"\n</code></pre> By not using brackets, it automatically assumes that the key is a string. By indexing with <code>.</code>, it automatically assumes we are indexing with a string. With this in mind, we can represent the properties of an instance of a <code>Player</code> class like so: <pre><code>local playerInstance = {\n    name = \"Kazi\",\n    gender = \"Male\", -- I swear\n    age = 18,\n    health = 100,\n    maxHealth = 100,\n}\n</code></pre> Now, we can try to add some behavior to the <code>playerInstance</code> with a method! <pre><code>playerInstance.greetings = function()\n    print(playerInstance.name, \"says hi!\", \"They are a\", playerInstance.age, \"year old\", playerInstance.gender)\nend\n\nplayerInstance.greetings()\n</code></pre> Output:</p> <p>\"Kazi\" \"says hi!\" \"They are a\" 18 \"year old\" \"Male\"</p> <p>This works! But there is an issue with this. It would be a huge pain to constantly do this with every single <code>Player</code> object, having to define every property and make unique functions for every method in it. To fix this issue, we will need to make a constructor function (a function that creates and returns an object based on the class), and a class table that will contain all the methods that will then be referenced by the object. A constructed object based on a class is called an instance of the class.</p>"},{"location":"Chapter%203/#32-classes-in-lua","title":"3.2 - Classes in Lua","text":"<p>In lua, classes and constructors are usually created in the same table. Before, when defining a method inside of the <code>playerInstance</code> table, we did <code>playerInstance.greeting = function()</code>, but due to how frequently methods and functions stored in tables are, we will see that lua has another way of doing this. Now, let's create our class table and constructor function! <pre><code>local Player = {} -- Class table\n\n-- This will be our constructor function. Calling it \"new\" is standard convention\nfunction Player.new(name, gender, age, maxHealth) -- Doing `function table.x()` is shorthand for doing `table.x = function` or `table[\"x\"] = function()\n    local playerObject = {\n        name = name,\n        gender = gender,\n        age = age,\n        health = maxHealth,\n        maxHealth = maxHealth,\n\n    }\n\n    return playerObject\n\nend\n\nlocal playerInstance = Player.new(\"Kazi\", \"Male\", 18, 100)\n</code></pre> Nice! Now we can call <code>Player.new</code> every time we want to make a new <code>Player</code> instance. Now, let's give it some behavior. Since the behavior will always be the same between instances, we should not define it in the instance itself like properties, but instead store it in the base class and make them as methods that can work with any table instead of referring to one specific one: <pre><code>local Player = {}\n\nfunction Player.new(name, gender, age, maxHealth)\n    local playerObject = {\n        name = name,\n        gender = gender,\n        age = age,\n        health = maxHealth,\n        maxHealth = maxHealth,\n\n    }\n\n    return playerObject\n\nend\n\nfunction Player.greetings(instance)\n    print(instance.name, \"says hi!\", \"They are a\", instance.age, \"year old\", instance.gender)\nend\n\nlocal playerInstance = Player.new(\"Kazi\", \"Male\", 18, 100)\nPlayer.greetings(playerInstance)\n</code></pre> Output:</p> <p>\"Kazi\" \"says hi!\" \"They are a\" 18 \"year old\" \"Male\"</p> <p>It is a little bit fucked to have to directly use the base class in order to access the behavior of a specific instance though, it would be much nicer to just do <code>playerInstance.greetings(PlayerInstance)</code>. We could in theory just take every method inside the <code>Player</code> class table and store it inside the instances the same way we do with properties, but that can get very tedious! Instead, what if we could just made it so whenever we index <code>playerInstance</code> with something it doesn't contain, it instead just pulls it from the <code>Player</code> table automatically! Well, we can, yay!! Let's do it then!!!!</p>"},{"location":"Chapter%203/#33-metatables","title":"3.3 - Metatables","text":"<p>Metatables are a special feature of lua that allows you to change the way a table works. It can allow you to make it so you can add, subtract, divide, multiply, etc. a table, call it as a function, and much more. The thing we'd want to change for making objects is what happens when you index with a key that doesn't exist in a table: <pre><code>local table = {\n    key1 = \"value\"\n}\n\nlocal x = table.key2\n</code></pre></p> What do you expect x to equal? nil  <p>Since <code>key2</code> does not exist/have a value in <code>table</code>, the default behavior of lua would be to just assume that it is <code>nil</code>. With metatables, we can override this default behavior. Then, when we do <code>playerInstance.greetings()</code>, we can make it so instead of <code>greetings</code> just being nil (since it does not exist within <code>playerInstance</code>) and everything not working, it will just pull the <code>greetings</code> function from <code>Player</code>.</p> <p>Metatables work through metamethods, functions that define what the new behavior will be stored inside of a table. The metamethod we are interested in is <code>__index</code>, which is called whenever you index a table with a key it does not have a value for. You then call <code>setmetatable</code> to attatch the metatable to a specific table. Here's an example to give a table a new default value: <pre><code>local table = {\n    key1 = \"value\"\n}\n\nlocal metatable = {\n    __index = function(tableBeingIndexed, index) -- Roblox will automatically pass in the table the metatable is attatched to and what you are trying to index it with as the two arguments\n        return \"default value for \"..index\n    end\n\n}\nsetmetatable(table, metatable)\n\nlocal w = table.key1\nlocal x = table.key2\nlocal y = table.key3\nlocal z = table.wow\n</code></pre></p> What is the value of w \"value\"  What is the value of x \"default value for key2\"  What is the value of y \"default value for key3\"  What is the value of z \"default value for wow\"  <p>Now, we can use <code>__index</code> to pull values from <code>Player</code> as default values for instances: <pre><code>local Player = {}\n\nfunction Player.new(name, gender, age, maxHealth)\n    local playerObject = {\n        name = name,\n        gender = gender,\n        age = age,\n        health = maxHealth,\n        maxHealth = maxHealth,\n\n    }\n\n    setmetatable(playerObject, {\n        __index = function(tableBeingIndexed, index)\n            return Player[index]\n        end,\n\n    })\n\n    return playerObject\n\nend\n\nfunction Player.greetings(instance)\n    print(instance.name, \"says hi!\", \"They are a\", instance.age, \"year old\", instance.gender)\nend\n\nlocal playerInstance = Player.new(\"Kazi\", \"Male\", 18, 100)\nplayerInstance.greetings(playerInstance)\n</code></pre> Now, on the last line, here is what will happen:</p> <ol> <li>It will try to get the value of <code>playerInstance.greetings</code></li> <li>Since it does not exist, it would normally just default to nil. However, it will check to see if it has a metatable with <code>__index</code>. It does, so it calls <code>__index</code> with <code>playerInstance, \"greetings\"</code></li> <li>This will return <code>Player[\"greetings\"]</code>, meaning that <code>playerInstance.greetings</code> will give us <code>Player.greetings</code></li> <li><code>Player.greetings</code> is then called with <code>playerInstance</code></li> </ol> <p>Since it is common with OOP to pass a table into its method, like we do with <code>playerInstance.greetings(playerInstance)</code>, lua has some shorthand for that specifically. By using <code>:</code> instead of <code>.</code>, lua will make the first argument the table, meaning you can do <code>playerInstance:greetings()</code>. Similarly, we can define methods the same way: <pre><code>function Player:greetings()\n    print(self.name, \"says hi!\", \"They are a\", self.age, \"year old\", self.gender)\nend\n</code></pre> <code>self</code> is used to refer to the first parameter, which is assumed to be a class instance.</p> <p>Since it is really common to have it so <code>__index</code> pulls values from another table, lua has some shorthand for <code>__index</code> that allows us to simplify the code: <pre><code>local Player = {}\n\nfunction Player.new(name, gender, age, maxHealth)\n    local playerObject = {\n        name = name,\n        gender = gender,\n        age = age,\n        health = maxHealth,\n        maxHealth = maxHealth,\n\n    }\n\n    setmetatable(playerObject, {\n        __index = Player,\n    })\n\n    return playerObject\n\nend\n\nfunction Player:greetings()\n    print(self.name, \"says hi!\", \"They are a\", self.age, \"year old\", self.gender)\nend\n</code></pre> This will do the same thing as before. Furthermore, since every instance has the same metatable, there isn't a need to create a new metatable every time we construct an object. We can instead just make the class table also a metatable! <pre><code>local Player = {}\n\nPlayer.__index = Player\n\nfunction Player.new(name, gender, age, maxHealth)\n    local playerObject = {\n        name = name,\n        gender = gender,\n        age = age,\n        health = maxHealth,\n        maxHealth = maxHealth,\n\n    }\n\n    setmetatable(playerObject, Player)\n\n    return playerObject\n\nend\n</code></pre></p> <p>Now that we finally have it set up, let's add some new methods to the <code>Player</code> class: <pre><code>local Player = {}\n\nPlayer.__index = Player\n\nfunction Player.new(name, gender, age, maxHealth)\n    local playerObject = {\n        name = name,\n        gender = gender,\n        age = age,\n        health = maxHealth,\n        maxHealth = maxHealth,\n\n    }\n\n    setmetatable(playerObject, Player)\n\n    return playerObject\n\nend\n\nfunction Player:greetings()\n    print(self.name, \"says hi!\", \"They are a\", self.age, \"year old\", self.gender)\nend\n\nfunction Player:damage(amount)\n    if amount &lt; 10 then\n        print(\"Eh wasn't that bad\", self.name, \"only took\", amount, \"damage\")\n    else\n        print(\"OH FUCK OWOWOWOW FUCK OW OW\", self.name, \"TOOK\", amount, \"DAMAGE OH FUCK\")\n    end\n\n    self.health = self.health - amount\n    if self.health &lt;= 0 then\n        print(\"Oh FUCK\", self.name, \"DIED OH NOOOO!!\")\n    end\n\nend\n\nfunction Player:revive()\n    if self.health &gt; 0 then\n        print(self.name, \"is already alive lol\")\n    else\n        self.health = self.maxHealth\n        print(\"Wow!\", self.name, \"was revived :D they now have\", self.health, \"health!\")\n    end\n\nend\n</code></pre> Now, let's see if you can tell what the following will do: <pre><code>local kazi = Player.new(\"Kazi\", \"Male\", 18, 100)\n\nkazi:damage(5) -- What is the output here? (Q1)\nkazi:damage(10) -- What is the output here? (Q2)\nkazi:revive() -- What is the output here? (Q3)\nkazi:damage(90) -- What is the output here? (Q4)\nkazi:revive() -- What is the output here? (Q5)\n</code></pre></p> Q1 \"Eh wasn't that bad\" \"Kazi\" \"only took\" 5 \"damage\"  Q2 \"OH FUCK OWOWOWOW FUCK OW OW\" \"Kazi\" \"TOOK\" 10 \"DAMAGE OH FUCK\"  Q3 \"Kazi\" \"is already alive lol\"  Q4 \"OH FUCK OWOWOWOW FUCK OW OW\" \"Kazi\" \"TOOK\" 90 \"DAMAGE OH FUCK\"\"Oh FUCK\" \"Kazi\" \"DIED OH NOOOO!!\"  Q5 \"Wow!\" \"Kazi\" \"was revived :D they now have\" 100 \"health!\"  <p>Good job queens! We basically ready to move onto Roblox now, but I'll probably write a quick chapter with some tips for lua and coding in general.</p>"},{"location":"Chapter%203b/","title":"Chapter 3b","text":""},{"location":"Chapter%203b/#state-and-behavior-object-oriented-programming","title":"State and Behavior, Object Oriented Programming","text":""},{"location":"Chapter%203b/#3b0-tips","title":"3b.0 - Tips!","text":"<p>Here's just some misc advice, concepts, and stuff about lua I couldn't really fit anywhere else.</p>"},{"location":"Chapter%203b/#3b1-lua-stuff","title":"3b.1 - Lua Stuff","text":"<p>In lua, you can simplify <code>x = x + 1</code> as <code>x += 1</code>. This applies for all operations.</p> <p>There are ternary operators in lua. They look similar to if statements, but they are NOT if statements, and instead of running code, they just select values. All ternary operations can be represented with boolean operations (<code>and</code>/<code>or</code>) but they are typically easier to follow along: <pre><code>local person = \"Kazi\"\nlocal description = if person == \"Kazi\" then \"So so pretty and cute the best #1 etc\" elseif person == \"Calla\" then \"Alright I guess...\" else \"Mid\"\n</code></pre></p> What is decription equal to? \"So so pretty and cute the best #1 etc\""},{"location":"Chapter%203b/#3b2-coding-tips","title":"3b.2 Coding Tips","text":"<p>Don't use an if statement if you don't have to. Here's an example: <pre><code>local person = \"Kazi\"\nlocal cuteness\nif person == \"Kazi\" then\n    cuteness = 999999999\nelse\n    cuteness = 0\nend\n</code></pre> While this does work, it runs slower and takes longer to write than doing: <pre><code>local person = \"Kazi\"\nlocal cuteness = person == \"Kazi\" and 999999999 or 0\n</code></pre> or the equivilent with ternary operations. The practice of avoiding branches, of which the <code>if</code> statement is one of, is called branchless programming.</p> <p>On the topic of branches, try to avoid <code>if</code>-<code>else</code> spam: <pre><code>if ... then\nelseif ... then\nelseif ... then\nelseif ... then\nelseif ... then\nelseif ... then\nelseif ... then\nelse\nend\n</code></pre> This is some nasty yandev bs. Not only does it end up looking ugly as shit, it's also slow. And God forbid only the last condition is met or it reaches the <code>else</code>, then it'd have checked every. single. condition before it. Which is slow as shit. If you're at this point, there's always 100% a better way to do it.</p> <p>Some more advice with branches: it is often easier to read conditions and change their order if you use guard clauses. Guard clauses reimagine things from being \"if this condition is met, then do this\" to being \"if this condition isn't met, then don't do anything. Otherwise, continue as usual\": <pre><code>local condition = true\nlocal function doesUseGuardClause()\n    if not condition then\n        return -- Recall that returning will always just end a function right there\n    end\n\n    print(\"Printed!\")\n\nend\nlocal function doesNotUseGuardClause()\n    if condition then\n        print(\"Printed!\")\n    end\n\nend\n</code></pre> By doing it this way, it's a lot easier to change the order of conditions and keep track of which conditions have been checked. This can be done within functions using <code>return</code> and loops using <code>continue</code> (<code>continue</code> forcibly stops the rest of the loop from running and does a new iteration).</p> <p>Now we ready to get into ROBLOX!! WOOOHOO!!!!!</p>"},{"location":"Chapter%204/","title":"Chapter 4","text":""},{"location":"Chapter%204/#game-development","title":"Game Development","text":""},{"location":"Chapter%204/#40-roblox-game-development","title":"4.0 - Roblox Game Development","text":"<p>A lot of these concepts are found in/can apply in other engines and languages, the main focus for this and from now on will be Roblox Studio. We gonna be looking at how the Roblox engine works so we can finally script in it!</p>"},{"location":"Chapter%204/#41-data-models","title":"4.1 - Data Models","text":"<p>Roblox handles everything as instances of objects; models, scripts, players, they are all instances! Wow! Roblox uses a parent-child hierarchy:  For example, here <code>Workspace</code> is the parent of <code>Baseplate</code>, and <code>Baseplate</code> is a child of <code>Workspace</code>. Every instance has a <code>Parent</code> property that says its parent and can be used to reparent. Children can be accessed via indexing the parent with the name of the child, like a property (e.g. <code>Workspace.Baseplate</code> or <code>Workspace[\"Baseplate\"]</code>) or with the <code>:FindFirstChild</code> method every instance has (e.g. <code>Workspace:FindFirstChild(\"Baseplate\")</code>). It is important to note that if a child with the name you are looking for does not exist, trying to access it via indexing will result in an error, but using <code>:FindFirstChild</code> will simply return <code>nil</code> (e.g. <code>Workspace.Kazi</code> would error as there is no <code>Kazi</code> in <code>Workspace</code>, but <code>Workspace:FindFirstChild(\"Kazi\")</code> would just return <code>nil</code> without erroring).</p> <p>Children of children are referred to as descendants, and parents of parents are referred to as ancestors. There are appropriately <code>:FindFirstAncestor</code> and <code>:FindFirstDescendant</code> methods that work similarly to <code>:FindFirstChild</code>. <code>:FindFirstChild</code> also takes a second parameter for recursion, which effectively makes it work like <code>:FindFirstDescendant</code> if the second argument is true. The highest ancestor is <code>game</code>, which is of the <code>DataModel</code> class. Roblox has a default variable for <code>game</code>, meaning that you could do <code>game.Workspace.Baseplate</code>, and also has a default variable for <code>workspace</code> that is equal to <code>game.Workspace</code>.</p> <p>Classes for Roblox instances typically have multiple levels of inheritence. While it can be hard to keep track of, Roblox has mostly well-made documentation for every class. The documentation also includes tutorials, which can be helpful, but I'm kind of skeptical of tutorials in general. Instances have the <code>ClassName</code> property which is always set to the specific class the instance is. They also have the <code>:IsA(class)</code> function which returns <code>true</code> if the instance's class either is the specified class or a subclass (class that inherits from another class) of the specified class.</p>"},{"location":"Chapter%204/#42-services","title":"4.2 - Services","text":"<p>Singletons are a type of class that can only have one instance. Does that seem pointless? Well yes, that's because it is! Roblox has services which are singletons that are all children of <code>game</code> and can be accessed with <code>game:GetService(serviceName)</code>. <code>Workspace</code> is a service, so it can be accessed with <code>game:GetService(\"Workspace\")</code>. Most services have specific methods and events (will get into in a later chapter) that allow you to interact with Roblox's engine in different way or perform specific tasks.</p>"},{"location":"Chapter%204/#43-netcode-and-networking","title":"4.3 - Netcode and Networking","text":"<p>Netcode describes how an application handles multiple clients (users) that interact with each other. The process of one client updating other clients on what it does, and vice versa, is called replication (e.g. whenever a player moves, their position is replicated to other clients).</p> <p>The simplest method for connecting clients to each other is peer-to-peer (p2p). With p2p, clients just send information to every other connected client whenever they want to replicate. While this is simple, it becomes an increasingly higher and higher load on every client once more clients are connected, and if there is every a desync, it is essentially impossible to figure out which client's version of what's going on is the true one. Because of this, p2p is often only used for applications with a low amount of users that connect to each other (e.g. a game based around 1v1ing another player would work fine with p2p). The disadvantages of p2p are solved by the client-server architecture. With this, clients connect to a central server that handles all replication. Clients request to replicate information to the server, which can then either accept the request and propogate the replication to other clients, or deny it and undo it on the client that requested it. With this, it's a lot easier to conenct multiple clients, keep them synchronized, and keep track fo and validate what's happening. Roblox uses the client-server architecture.</p> <p>Synchronizing clients itself can be handled different ways. Delay-based netcode is the simplest way: whenever a client is desynced, simply pause every other client until they're back in sync. If this sounds bad, that's because it is! It essentially means if one player is lagging, then every other client has to wait for them to stop lagging, and whenever the client wants to do anything, it has to wait for the server in order to see it happen. A far better method is rollback-based netcode. With it, all requests are simulated immedeately on the client at the same time of replication. If the server denies the replication, it does a rollback and undoes the simulation on the requesting client. If it accepts the replication, it propogates it to other clients. This method allows for immedeate feedback and doesn't force other players to endure another's lag. For all physics replication (e.g. movement), Roblox has built-in rollback handling. For type of replication you specifically script, you have to handle synchronization yourself if you want it, but it will never be delay-based.</p> <p>Wow! That's the overview! Now we can actually script in Roblox and learn more about how it works by example!</p>"}]}