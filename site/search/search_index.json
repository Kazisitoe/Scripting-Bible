{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#hi-im-kazi","title":"Hi, I'm Kazi!","text":"<p>Learn my ways learn how to master scripting. Be like me. I know you wish you were.</p>"},{"location":"#marvel-at-this-cat","title":"Marvel at this cat","text":"<p>He is my good friend</p>"},{"location":"Chapter%201/","title":"Chapter 1","text":""},{"location":"Chapter%201/#basics","title":"Basics","text":""},{"location":"Chapter%201/#10-basic-cs-and-programming-concepts","title":"1.0 - Basic CS and Programming Concepts","text":"<p>While you don't really need to know CS in order to code, it's very useful to understand the way your code works in the first place so you can better decide the best way to do what you want to do. Probably the most important things to have an understanding of is basic terminology and also how memory works.</p> <p>Examples for these concepts will be provided in pseudo-code (not actually real code) since this doesn't necessarily have to do with coding itself and is universal to any coding language.</p>"},{"location":"Chapter%201/#11-terminology","title":"1.1 - Terminology","text":"<ul> <li>Programming language: A language used to write programs (wow)<ul> <li>Compiled language: A programming language that is made to be directly ran by the computer itself; instructions for the computer</li> <li>Interpreted language: Also called a scripting language. A programming language that is made to be run by a separate program (the interpreter); instructions for another program</li> </ul> </li> <li>High/low level language: The further a language is away from directly interacting with the computer, the higher level it is. Scripting languages are generally high level since they interact with a program that interacts with the computer instead of just interacting with the computer</li> <li>Variable: Something that stores a value, concept from algebra</li> <li>Data types: The different types of information that can be stored in a variable. These can be simple values like numbers, letters, and words (primitive data types) or more complicated structures<ul> <li>Complex data type: A data type that holds multiple values within it</li> </ul> </li> <li>Function: Something that (generally) can take inputs (parameters), run some code, and return outputs, concept from algebra<ul> <li>Void function: A function that doesn't give an output</li> </ul> </li> <li>Bit: The smallest unit of stored information; a single binary digit (0 or 1). Most values are encoded as multiple bits, usually powers of 2.</li> </ul> <p>There is some more terminology but that will be explained within the rest of the doc sections!!</p>"},{"location":"Chapter%201/#12-memory-basics","title":"1.2 - Memory Basics","text":"<p>Memory is what a computer uses to store information. All information is stored as binary values, which basically every language will automatically do for you. Say you were to have some code like this: <pre><code>x = 10\n</code></pre> In this example, <code>x</code> is a variable set to the value <code>10</code>. Wow! When this is executed, some memory is allocated (reserved) for <code>x</code>, and is filled in with the binary value for <code>10</code>. Wherever this memory is allocated is called the memory address. Variables generally can fill their allocated memory with a new value, allowing it to change over time: <pre><code>x = 10\nx = 20\nx = 5\n</code></pre></p> <p>Generally, variables will always allocate their own memory, so if you set one variable to be equal to another variable: <pre><code>x = 10\ny = x\n</code></pre> then they will both have different memory addresses. This means that if <code>x</code> were to be changed to a different value in this example: <pre><code>x = 10\ny = x\nx = 5\n</code></pre> then <code>y</code> would still remain <code>10</code> even though it was set to <code>x</code> which is now <code>5</code>; instead of copying <code>x</code> itself it copies whatever <code>x</code> is currently equal to. There are, however, reference variables which do refer to the exact memory address of another variable, effectively making it so it changes with it: <pre><code>x = 10\ny references x\nx = 5\n</code></pre> in this example, <code>y</code>, like <code>x</code>, will start out as <code>10</code> and be changed to <code>5</code>. Most higher-level languages will not use references unless it is for more complicated data types than just numbers.</p> <p>Memory is physically stored, so there is a limit to how much can be stored. You will generally never hit this limit on a modern computer unless you REALLY fuck up, but generally the less you have available the slower everything is, so you want to avoid keeping useless memory allocated. When useless memory is kept allocated, it is called a memory leak. Scripting languages typically have garbage collectors that detect when memory is 100% not used and won't be used and automatically deallocates it, doing most of the job for you.</p>"},{"location":"Chapter%201/#13-data-types","title":"1.3 - Data Types","text":"<p>Data is always stored in the same binary format, so the computer uses its data type to know how to understand it. Different data types will require more or less memory to store information. The most common data types are:</p> <ul> <li>Int(integer): A positive or negative whole number</li> <li>Float(ing point): A number that can have a decimal<ul> <li>Double: A float that uses twice the information, so it can store bigger numbers</li> </ul> </li> <li>Bool(ean): A binary value, usually represented as being either <code>true</code> or <code>false</code></li> <li>Str(ing): Any text/characters. Typically represented by wrapping it between <code>\"\"</code> or <code>''</code>. Strings might sometimes look like other value types (e.g. <code>\"true\"</code> or <code>\"5\"</code>) but they are treated just as any other string</li> <li>Null: Called <code>nil</code> in lua, just represents there being no value at all</li> </ul> <p>A language that is strongly typed will require you to manually define the type of a variable. Many scripting languages aren't, and instead automatically assume it based on the value.</p> <p>There are more complex data types, but these generally depend on the language itself. The most common one that is practically universal between languages is the array. An array is essentially an ordered list of multiple values. Most languages are 0-index, meaning that the first value stored in an array is treated like the 0th value, but Lua (what Roblox uses) is 1-index, meaning that the first value is treated as the 1st. Here is an example of the way an array works in a 1-index language: <pre><code>a = [5, \"something\", false]\n\nx = a[1]\ny = a[2]\nz = a[3]\n</code></pre> In this example, <code>a</code> is set to an array containing the values <code>5</code> (an int), <code>\"something\"</code> (a string), and <code>false</code> (a bool). <code>x</code> is then set to the <code>1</code>st element of the array (<code>5</code>), <code>y</code> to the <code>2</code>nd (<code>\"something\"</code>), <code>z</code> to the <code>3</code>rd (<code>false</code>). This process of referring to a specific value within a complex data structure is called indexing.</p>"},{"location":"Chapter%201/#14-functions","title":"1.4 - Functions","text":"<p>A function can generally take in any number of inputs (parameters) and return any number of outputs. Functions can also store code within them that runs whenver the function is called (used). Whatever values are passed into the function (arguments) will fill in the values of the parameters. Might not have been the simplest way to explain it but an example should clear stuff up (using Lua for the example this time): <pre><code>-- In lua, doing -- makes the rest of the line a comment. You can write anything in a comment and it won't run\nfunction add(number1, number2) -- All the code between here and 'end' will run when the funciton is called\n    -- The parameters are 'number1' and 'number2'\n\n    local sum = number1 + number2 -- 'local' basically means in Lua that this is a new variable and not just changing the value of one that already exists\n    return sum -- Returning values ends the function immedeately and gives it a value\n\nend\n\nlocal x = add(5, 7) -- The arguments here are 5 and 7. This means that when 'add' is called this time, the parameter number1 will be 5 and the parameter number2 will be 7. This will make the sum variable 5+7 and thus 12 will be returned. x is set to the return value, so x is now 12\n\nlocal y = add(8, 9) - 1 -- Figure out what the arguments are, what 'sum' will be equal to in this case, what gets returned, and what y is equal to`\n</code></pre></p> The arguments are: 8 and 9, meaning that when add is called in the highlighted line, number1 will equal 8 and number2 will equal 9   The value returned is: 17. sum is set to equal number1 (8) + number2 (9) which is 17. sum is then returned  y will be equal to: 16. y is set to equal the return value of add(8, 9) - 1. The return value is 17, and 17 - 1 is 16.  <p>Most programming languages come with many built-in functions. The <code>print</code> function will log any arguments into the program's output. <pre><code>print(\"something\", 5-9, false)\n</code></pre> Output:</p> <p>\"something\"  -14  false</p>"},{"location":"Chapter%201/#15-operations","title":"1.5 - Operations","text":"<p>Operations are pretty simple. The symbols for operations are almost entirely the same between languages, but there are some differences and I will be using the way they are done in lua. In lua, the value types number (int, float, and double are all treated as one type in lua), string, and boolean all have unique operations, and there are some operations that are universal to all data types. They are all generally straightforwards, although boolean operations are somewhat difficult.</p> <p>Universal operations:</p> <ul> <li>Equality: <code>a == b</code> outputs <code>true</code> if the values are equivilent and <code>false</code> otherwise<ul> <li><code>5 == 3</code> outputs <code>false</code></li> </ul> </li> <li>Unequality: <code>a ~= b</code> outputs <code>true</code> if the values are not the same and <code>false</code> otherwise<ul> <li><code>5 ~= 3</code> outputs <code>true</code></li> </ul> </li> <li>If these are used with complex data types, it will compare their memory addresses instead of the values themselves</li> </ul> <p>Numerical operations (arithmetic):</p> <ul> <li>Addition: <code>a + b</code> outputs the sum of the two numbers<ul> <li><code>5 + 3</code> outputs <code>8</code></li> </ul> </li> <li>Subtraction: <code>a - b</code> outputs the difference of the two numbers<ul> <li><code>5 - 3</code> outputs <code>2</code></li> </ul> </li> <li>Multiplication: <code>a * b</code> outputs the product of the two numbers<ul> <li><code>5 * 3</code> outputs <code>15</code></li> </ul> </li> <li>Division: <code>a / b</code> outputs the quotient of the two numbers<ul> <li><code>5 / 3</code> outputs <code>1.66666666666...</code></li> </ul> </li> <li>Exponentiation: <code>a ^ b</code> outputs <code>a</code> to the power of <code>b</code><ul> <li><code>5 ^ 3</code> outputs <code>125</code></li> </ul> </li> </ul> <p>These all follow the standard order of operations. Parentheses can be used.</p> <p>Numerical operations (Inequalities):</p> <ul> <li>Greater than or equal to: <code>a &gt;= b</code> outputs <code>true</code> if <code>a</code> is greater than or equal to <code>b</code> and <code>false</code> otherwise<ul> <li><code>5 &gt;= 3</code> outputs <code>true</code></li> </ul> </li> <li>Less than or equal to: <code>a &lt;= b</code> outputs <code>true</code> if <code>a</code> is less than or equal to <code>b</code> and <code>false</code> otherwise<ul> <li><code>5 &lt;= 3</code> outputs <code>false</code></li> </ul> </li> </ul> <p>String operations (there's really only one):</p> <ul> <li>Concatination: <code>a .. b</code> combines the two strings into one<ul> <li><code>\"combined \"..\"words\"</code> outputs <code>\"combined words\"</code></li> </ul> </li> </ul>"},{"location":"Chapter%201/#151-boolean-operations","title":"1.5.1 - Boolean Operations","text":"<p>These get their own sections because they're kind of complicated. Boolean operations can actually be used on any data type, not just booleans. However, they are based on boolean math and treat data types as if they were either <code>true</code> or <code>false</code> even if they are not booleans. If a data type is treated as being <code>true</code> it is truthy and if it is treated as being false it is falsey. In lua, all data types are truthy except <code>false</code> and <code>nil</code>.</p> <ul> <li><code>a and b</code> outputs <code>b</code> if <code>a</code> is truthy, otherwise outputs <code>a</code><ul> <li><code>true and 5</code> outputs <code>5</code></li> <li><code>false and 3</code> outputs <code>false</code></li> <li><code>nil and false</code> outputs <code>nil</code></li> </ul> </li> <li><code>a or b</code> outputs <code>a</code> if <code>a</code> is truthy, otherwise outputs <code>b</code><ul> <li><code>true or 5</code> outputs <code>true</code></li> <li><code>false or 3</code> outputs <code>3</code></li> <li><code>nil or false</code> outputs <code>false</code></li> </ul> </li> <li><code>not a</code> outputs <code>false</code> if <code>a</code> is truthy, otherwise outputs <code>true</code><ul> <li><code>not true</code> output <code>false</code></li> <li><code>not 5</code> outputs <code>false</code></li> <li><code>not nil</code> outputs <code>true</code></li> <li><code>not false</code> outputs <code>true</code></li> <li><code>not not 2</code> outputs <code>true</code></li> </ul> </li> </ul> <p>Now try to see if you can figure out these values!</p> 5 and 3 3  2 or 3 2  5*5 or 1 25  nil and 2*2 nil  true and \"wow\" or \"woah\" \"wow\"  (not true) and \"wow\" or (not not \"woah\") true  5 == 3 and \"calla likes girls\" or 3 == 2 and \"what\" or 2*2 == 2^2 and \"kazi is so pretty\" \"kazi is so pretty\"  <p>That's it for all the computer science/math based stuff! Wow! You did it! Yay! More coming soon!</p>"},{"location":"Chapter%201b/","title":"Chapter 1b","text":""},{"location":"Chapter%201b/#basics-in-lua","title":"Basics in Lua","text":""},{"location":"Chapter%201b/#1b0-basic-programming-concepts-in-lua","title":"1b.0 - Basic Programming Concepts in Lua","text":"<p>The previous chapter was more general to all programming languages. Since the rest of this doc will be on lua specifically, I'll show how everything in the previous chapter works in lua. Well that's kind of a lie, it'll actually be Luau, Roblox's derivitive of lua. Luau has all the features of lua with some extra stuff on top of it.</p>"},{"location":"Chapter%201b/#1b1-complex-data-types","title":"1b.1 - Complex Data Types","text":"<p>A lot of programming languages have the complex data types hashmap/dictionary and array. An array, as explained before, just contains multiple values in an ordered list. A hashmap maps \"keys\" to \"values\". For example, in javascript <pre><code>let Player = {\n    \"health\": 100, // Key is \"health\", value is 100\n    \"name\": \"Kazi\", // Key is \"name\", value is \"Kazi\"\n    \"age\": 18, // Key is \"age\", value is 18\n\n}\n</code></pre> You can then index it to get values (e.g. <code>Player[\"health\"]</code> will be <code>100</code>)</p> <p>Instead of having dictionaries and arrays, lua has tables which can represent both: <pre><code>local arrayTable = {5, \"something\", false}\nlocal playerTable = {\n    [\"health\"] = 100,\n    [\"name\"] = \"Kazi\",\n    [\"age\"] = 18,\n\n}\n</code></pre> An array table is just an automated way to do the following: <pre><code>{\n    [1] = ...,\n    [2] = ...,\n    [3] = ...,\n    ...\n}\n</code></pre> You can modify the values inside of a table, or even add new ones: <pre><code>arrayTable[3] = true -- arrayTable is now {5, \"something\", true}\nplayerTable[\"cute\"] = true -- playerTable is now { [\"health\"] = 100, [\"name\"] = \"Kazi\", [\"age\"] = 18, [\"cute\"] = true, }\n</code></pre></p>"},{"location":"Chapter%201b/#1b2-references","title":"1b.2 - References","text":"<p>Lua doesn't have references for the most part. However, variables set to tables will always act as references: <pre><code>local playerTable = {\n    [\"health\"] = 100,\n    [\"name\"] = \"Kazi\",\n    [\"age\"] = 18,\n    [\"cute\"] = true,\n\n}\n\nlocal playerNamedKazi = playerTable\nplayerNamedKazi[\"health\"] = 80 -- This affects playerTable!! Now they will both be { [\"health\"] = 80, [\"name\"] = \"Kazi\", [\"age\"] = 18, [\"cute\"] = true, }\n</code></pre></p> <p>Wow! We good for progressing now!</p>"},{"location":"Chapter%202/","title":"Chapter 2","text":""},{"location":"Chapter%202/#conditionals-and-iterations","title":"Conditionals and Iterations","text":""},{"location":"Chapter%202/#20-conditionals-and-iterations-in-lua","title":"2.0 - Conditionals and Iterations in Lua","text":"<p>Conditionals are fundamental for programming. They allow your code to do different things depending on the situation. Iteration is fundamental for automating things and making code less repetitive. Wow!</p>"},{"location":"Chapter%202/#21-conditionals","title":"2.1 - Conditionals","text":"<p>A conditional is something that runs code only if a certain condition is met. The most basic conditional is the <code>if</code> statement: <pre><code>if (condition) then\n    -- run something\nend\n</code></pre> The <code>if</code> statement evaluates a single condition. If whatever is put into it is truthy, then the code inside of it (between <code>then</code> and <code>end</code>) will run. Otherwise, it skips over to <code>end</code>. For example: <pre><code>local age = 16\n\nif age &lt; 18 then\n    print(\"Roblox devs want you\")\nend\n</code></pre> Here, <code>age &lt; 18</code> gives the value <code>true</code>. Since <code>true</code> is truthy, the code inside of it runs. There are two extra conditionals that function within an <code>if</code> statement: <code>elseif</code> and <code>else</code>: <pre><code>if (condition1) then\n    print(\"condition1 is truthy, only this will run\")\nelseif (condition2) then\n    print(\"condition1 is falsey but condition2 is truthy! Only this will run\")\nelseif (condition3) then\n    print(\"condition1 and condition2 are falsey but condition3 is truthy! Only this will run\")\nelse\n    print(\"Every above condition was falsey, so only this will run\")\nend\n</code></pre></p>"},{"location":"Chapter%202/#22-iteration","title":"2.2 - Iteration","text":"<p>There are many ways to iterate in lua. Iteration is the process of repeating an instruction multiple times, a single repetition being called an iteration. It can be achieved with loops and recursive functions. Both are fundamentally based on conditionals. When iterating, it is important to make sure that the iteration eventually ends or pauses, otherwise it will cause a stack overflow error where it essentially tries and fails to do an infinite amount of tasks at once. For most of the following examples, the methods for iteration will count upwards from <code>1</code> and stop when it reaches <code>10</code>.</p>"},{"location":"Chapter%202/#23-recursive-functions","title":"2.3 - Recursive Functions","text":"<p>A recursive function is a function that calls itself within its own execution: <pre><code>local function countToTen(currentNumber)\n    print(\"Counted\", currentNumber)\n\n    if currentNumber &lt; 10 then\n        countToTen(currentNumber + 1)\n    end\n\nend\n\ncountToTen(1)\n</code></pre> The function will first on the last line run with the argument <code>1</code>, meaning that <code>currentNumber</code> will equal <code>1</code>. It will then print <code>\"Counted\" 1</code> and check if <code>currentNumber &lt; 10</code>. As <code>1 &lt; 10</code>, this will result in <code>true</code>, and thus the code inside of the <code>if</code> statement runs. It calls itself again with the argument <code>currentNumber + 1</code>, which would be <code>1 + 1</code>, meaning this time <code>currentNumber</code> will be <code>2</code>. It will keep doing this over and over again until the condition checked by the <code>if</code> statement is false, which is when the argument is <code>10</code>. This will result in the following output:</p> <p>\"Counted\" 1 \"Counted\" 2 \"Counted\" 3 \"Counted\" 4 \"Counted\" 5 \"Counted\" 6 \"Counted\" 7 \"Counted\" 8 \"Counted\" 9 \"Counted\" 10</p>"},{"location":"Chapter%202/#24-while-loop","title":"2.4 - While Loop","text":"<p>Generally, for something as simple as this, a loop is prefered. The <code>while</code> loop repeatedly evaluates a condition and runs code until thaat condition is falsey: <pre><code>local currentNumber = 1\nwhile currentNumber &lt;= 10 do\n    print(\"Counted\", currentNumber)\n\n    currentNumber = currentNumber + 1\n\nend\n</code></pre> The way this code works is that it first evaluates <code>currentNumber &lt;= 10</code>. Since that is <code>true</code> and thus truthy, the code inside the <code>while</code> loop runs. By the end of this, <code>currentNumber</code> becomes <code>2</code>. As <code>2</code> is still less than or equal to <code>10</code>, the code inside the <code>while</code> loop will run again. It will keep doing this until <code>currentNumber</code> becomes <code>11</code>, and as <code>11 &lt; 10</code> would give false, the code inside the while loop would stop running. It is important to note that this uses <code>&lt;= 10</code> whereas the recursive function uses <code>&lt; 10</code> as <code>currentNumber</code> is increased before it checks its value <code>while</code> loop while it's effectively increased after it checks its value.</p> <p>Loops can prematurely be ended (similar to <code>return</code> in a function) using <code>break</code>: <pre><code>local currentNumber = 1\nwhile true do -- This condition will always be truthy, so the while loop will theoretically run infinitely. However, we eventually break out of it, so it does not cause a stack overflow\n    print(\"Counted\", currentNumber)\n\n    if currentNumber &gt;= 10 then\n        break\n    end\n\n    currentNumber = currentNumber + 1\n\nend\n</code></pre> The way the loop works this time is that it will firstly always run, as the condition we gave it is forever just <code>true</code>. It will then evaluate <code>currentNumber &gt;= 10</code> within the loop. As <code>1 &gt;= 10</code> is <code>false</code> which is falsey, what's inside of the <code>if</code> statement won't run and it will not break. <code>currentNumber</code> then is increased and the loop runs again. It will keep doing this until <code>currentNumber &gt;= 10</code> is <code>true</code>, where it will then finally break, ending before <code>currentNumber</code> can be set to 11.</p>"},{"location":"Chapter%202/#25-for-loop","title":"2.5 - For Loop","text":"<p>There are two types of <code>for</code> loops in Lua, one that simply counts a variable upwards until it reaches a certain value (exactly what we want for this) called the numeric for, and one that uses an iterator function (this one's more complicated) called the generic for. The first type works like this: <pre><code>for currentNumber = 1, 10, 1 do --1, 10, 1 means start at 1, stop at 10, increase by 1 every iteration. If a third number is not provided, it will automatically assume it is 1\n    print(\"Counted\", currentNumber)\nend\n</code></pre> This code will create a <code>currentNumber</code> variable that only exists within the <code>for</code> loop and then sets it to <code>1</code>. It will then run the code within it, and increase it by <code>1</code>. It will keep doing this until it reaches <code>10</code>, where it will then iterate one final time. Like <code>while</code> loops, <code>for</code> loops can be prematurely ended with <code>break</code>.</p>"},{"location":"Chapter%202/#251-generic-for-loop","title":"2.5.1 - Generic For Loop","text":"<p>The second type of <code>for</code> loop is definitely the most complicated method of iterating. The easiest way to do it is by analyzing an example: <pre><code>local function iterator(limit, currentValue)\n    currentValue = currentValue and currentValue + 1 or 1\n\n    if currentValue &gt; limit then\n        return nil\n    end\n\n    return currentValue\n\nend\n\nfor currentNumber in iterator, 10 do\n    print(\"Counted\", currentNumber)\nend\n</code></pre> Now we gotta break down how this all works. So, firstly, we can tell that this is a generic <code>for</code> as it uses <code>in</code> and an iterator function. The iteration function will then be called, and the arguments passed will be whatever is to the right of the indicator (<code>10</code>) and whatever is returned by the previous iteration (since there is no previous iteration, it will just be <code>nil</code>). This means in the first iteration, it calls <code>iterator(10, nil)</code>. The first line of the iterator function changes <code>currentValue</code> to be <code>currentValue and currentValue + 1 or 1</code>. Substituting in its value for this iteration gives us <code>nil and nil + 1 or 1</code> (which can be read as <code>(nil and nil + 1) or 1</code>). This simplifies to <code>nil or 1</code> which gives <code>1</code>. It then checks <code>currentValue &gt; limit</code>, which would be <code>1 &gt; 10</code>, which is false, meaning the <code>if</code> won't run. Finally, it returns <code>currentValue</code> which is again, now <code>1</code>. This return value gets put into <code>currentNumber</code>, and then the contents of the for loop run, printing out <code>\"Counted\" 1</code>. The for loop then iterates again, using the previous iteration's output (<code>1</code>) as an additional argument for <code>iterator</code>, meaning that this time it now calls <code>iterator(10, 1)</code>. This means that this time <code>limit</code> is still <code>10</code> and <code>currentValue</code> is now 1, resulting in <code>currentValue and currentValue + 1 or 1</code> giving <code>1 and 1 + 1 or 1</code>, or <code>1 and 2 or 1</code>, finally giving 2. The condition for the <code>if</code> statement still is not met, meaning that it returns <code>currentValue</code>, which is now <code>2</code>. This gets fed into <code>currentNumber</code>, it runs the code inside the <code>for</code> loop again, and this keeps repeating until <code>iterator</code> eventually returns nil.</p> <p>That was a lot of information wow. Good job princesses!</p>"}]}